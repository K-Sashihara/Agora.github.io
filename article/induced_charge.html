<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Article | Physics Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&family=Roboto+Mono&display=swap');
        body { font-family: 'Noto Serif JP', serif; } .mono { font-family: 'Roboto Mono', monospace; }
        html[lang="en"] .lang-ja { display: none; } html[lang="ja"] .lang-en { display: none; }
        .lang-btn-active { font-weight: bold; text-decoration: underline; }
        article p { margin-bottom: 1.5rem; color: #374151; line-height: 1.8; }
        .math-block { background: #f9fafb; padding: 1.5rem; border-radius: 0.5rem; margin: 2rem 0; overflow-x: auto; }
        code { font-family: 'Roboto Mono', monospace; background: #1f2937; padding: 0.2rem 0.4rem; border-radius: 0.25rem; font-size: 0.9em; }
        pre { background: #1f2937; color: #f9fafb; padding: 1.5rem; border-radius: 0.5rem; overflow-x: auto; margin: 2rem 0; font-size: 0.85em; }
    </style>
</head>
<body class="bg-white text-gray-900">
    <!-- Header -->
    <header class="max-w-3xl mx-auto pt-12 px-6">
        <div class="flex justify-between items-center mb-12">
            <a href="../index.html" class="text-xs uppercase tracking-widest border-b border-gray-900 pb-1 hover:text-gray-500 transition">← Back to Portfolio</a>
            <div class="text-xs mono space-x-2">
                <button onclick="setLanguage('ja')" id="btn-ja" class="lang-btn-active">JP</button>
                <span class="text-gray-300">/</span>
                <button onclick="setLanguage('en')" id="btn-en">EN</button>
            </div>
        </div>
    </header>
    <!-- Main Content -->
    <main class="max-w-3xl mx-auto px-6 pb-24">
        <!-- ここに記事コンテンツを追加 -->
        <!-- Snippet: Article Header -->
        <header class="mb-16">
            <div class="text-[10px] text-gray-400 uppercase tracking-[0.2em] mb-4 mono">SIMULATION / PHYSICS</div>
            <h1 class="text-3xl font-bold mb-6 leading-tight">
                <span class="lang-ja">有限導体に誘導される電荷のシミュレーション</span>
                <span class="lang-en">Simulation of Induced Charges in Finite Conductors</span>
            </h1>
            <div class="text-sm text-gray-500 mono">Date: 2026.02.24</div>
        </header>
        <article>
            <!-- Snippet: Text Section -->
            <section class="mt-12">
                <h2 class="text-xl font-bold mb-4 border-l-4 border-gray-900 pl-4">
                    <span class="lang-ja">はじめに</span><span class="lang-en">Introduction</span>
                </h2>
                <p class="lang-ja">本稿は有限導体に誘導される電荷をシミュレーションのコードとその結果についてまとめたものです。なお、この記事で紹介するコードはPythonで記述されています。また、詳しい説明については下記リンクのページに書いています。</p>
                <p class="lang-en">This article summarizes the code and results of simulating induced charges in finite conductors. The code presented here is written in Python. For a detailed explanation, please refer to the page linked below.(The page is in Japanese)</p>
            </section>

            <a href="../assets/induced_charge/code.html" class="text-blue-600 hover:underline">
                        <span class="lang-ja">詳しい説明を見る</span>
                        <span class="lang-en">Read Detailed Explanation(This page is written in Japanese)</span>
            </a>

            <br><br>

            <h2 class="text-xl font-bold mb-4 border-l-4 border-gray-900 pl-4">
                <span class="lang-ja">動機</span><span class="lang-en">Motivation</span>
            </h2>

            <p class="lang-ja">今回シミュレーションした、有限導体に誘導される電荷を求めるという問題は、実は数年前にTwitter(現X)で投稿されていた問題に触発されています。その問題は具体的には以下のような問題です。</p>
            <p class="lang-en">The problem of finding the induced charges in a finite conductor that we simulated was inspired by a problem posted on Twitter (formerly X) several years ago. The specific problem is as follows:</p>

            <div class="math-block">
                <p class="lang-ja">半径\(r\)の薄い導体円盤がある。中心軸(円盤の中心を通り、円盤に対して垂直な軸)に距離\(h\)の位置に点電荷\(q\)がある。このとき、導体円盤に誘導される電荷を求めよ。</p>
                <p class="lang-en">A thin conducting disk of radius \(r\) exists. A point charge \(q\) is located at a distance \(h\) from the center axis (the axis passing through the center of the disk and perpendicular to it). Find the induced charge on the conducting disk.</p>
            </div>

            <p class="lang-ja">実際の投稿では、この問題が解析的、あるいは近似的にでも解けることが示唆せれれていたのですが、未だ私は解けていません。どなたかわかる方がいらっしゃれば、教えて欲しいです、、、</p>
            <p class="lang-en">In the original post, it was suggested that this problem could be solved analytically or approximately, but I still haven't been able to solve it. If anyone knows how to solve it, I'd be grateful for any help.</p>

            <p class="lang-ja">今回は、この問題を二次元に落とし込み、しかも長方形型の導体を想定しています。かなり設定が離れてしまいましたが、それでも面白い結果が得られたと思います。メモリ効率などの問題を改善して、いつかは元の問題も解いてみたいです</p>
            <p class="lang-en">In this simulation, we reduced the problem to two dimensions and assumed a rectangular conductor. Although the setup is quite different from the original problem, we obtained interesting results. I plan to improve memory efficiency and other issues in order to solve the original problem someday.</p>

            <h2 class="text-xl font-bold mb-4 border-l-4 border-gray-900 pl-4">
                <span class="lang-ja">コード</span><span class="lang-en">Code</span>
            </h2>

            <p class="lang-ja">最後に、コードの全体を載せておきます。よかったら、自分なりに試して遊んでみてください。</p>
            <p class="lang-en">Finally, here is the full code. Feel free to try it out and experiment with it.</p>

            <!-- Snippet: Code Block -->
            <pre><code>
import numpy as np
import matplotlib.pyplot as plt
import scipy.sparse as sp

class simulator_2d():
    def __init__(self, nx, ny, nax, nay, q, nh, diff):
        if nx*ny*nax % 2 == 0:
            raise ValueError("nx*ny*nax must be odd.")

        self.nx = nx
        self.ny = ny
        self.nax = nax
        self.nay = nay
        self.q = q
        self.nh = nh
        self.diff = diff
        self.size = nx * ny - nax * nay + 1

        self.rho = np.zeros(self.size)
        self.rho[self.index((self.nx-1)//2, (self.ny-1)//2 - self.nh)] = self.q / (self.diff ** 2)

        self.index_list_right = np.zeros_like(self.rho, dtype=object)
        self.index_list_left = np.zeros_like(self.rho, dtype=object)
        self.index_list_up = np.zeros_like(self.rho, dtype=object)
        self.index_list_down = np.zeros_like(self.rho, dtype=object)
        self.map = np.zeros(nx*ny, dtype=int)

        for j in range(self.ny):
            for i in range(self.nx):
                idx = self.index(i, j)
                self.map[i + j*self.nx] = idx
                if i == 0:
                    self.index_list_left[idx] = None
                else:
                    self.index_list_left[idx] = self.index(i-1, j)

                if i == self.nx - 1:
                    self.index_list_right[idx] = None
                else:
                    self.index_list_right[idx] = self.index(i+1, j)

                if j == 0:
                    self.index_list_up[idx] = None
                else:
                    self.index_list_up[idx] = self.index(i, j-1)

                if j == self.ny - 1:
                    self.index_list_down[idx] = None
                else:
                    self.index_list_down[idx] = self.index(i, j+1)

        self.mask_right = (self.index_list_right == None)
        self.index_list_right = np.where(self.mask_right, 0, self.index_list_right).astype(int)
        self.mask_left = (self.index_list_left == None)
        self.index_list_left = np.where(self.mask_left, 0, self.index_list_left).astype(int)
        self.mask_up = (self.index_list_up == None)
        self.index_list_up = np.where(self.mask_up, 0, self.index_list_up).astype(int)
        self.mask_down = (self.index_list_down == None)
        self.index_list_down = np.where(self.mask_down, 0, self.index_list_down).astype(int)

    def step(self, x):
        return 0 if x < 0 else 1

    def index(self, i, j):
        if abs(i - (self.nx-1)//2) <= (self.nax-1)//2 and 0 <= j-(self.ny-1)//2 < self.nay:
            return -1
        else:
            return i + j * self.nx - min((max(0, j - (self.ny-1)//2 + self.step(i - (self.nx-self.nax)//2))), self.nay) * self.nax

    def re_index(self, array):
        return array[self.map].reshape(self.ny, self.nx)
    
    def test(self):
        for j in range(self.ny):
            print(self.map[j*self.nx:(j+1)*self.nx])

    def laplacian(self, phi):
        phi_right = np.where(self.mask_right, 0, phi[self.index_list_right])
        phi_left = np.where(self.mask_left, 0, phi[self.index_list_left])
        phi_up = np.where(self.mask_up, 0, phi[self.index_list_up])
        phi_down = np.where(self.mask_down, 0, phi[self.index_list_down])
        return (phi_right + phi_left + phi_up + phi_down - 4 * phi) / (self.diff ** 2)
    
    def poisson_solver(self, vector=False):
        A = sp.linalg.LinearOperator((self.size, self.size), matvec=lambda phi: -self.laplacian(phi))
        result = sp.linalg.bicgstab(A, self.rho)
        if vector:
            return result[0], self.re_index(result[0])
        else:
            return self.re_index(result[0])

    def plot(self, phi, E=False, step=25):
        print("Plotting potential distribution:")
        s = "nx:" + str(self.nx) + " ny:" + str(self.ny) + " nax:" + str(self.nax) + " nay:" + str(self.nay) + " q:" + str(self.q) + " nh:" + str(self.nh) + " diff:" + str(self.diff)
        
        phi = np.flipud(phi)
        x = np.arange(self.nx + 1) * self.diff
        y = np.arange(self.ny + 1) * self.diff
        X, Y = np.meshgrid(x, y, indexing='xy')

        plt.pcolormesh(X, Y, phi, shading='auto')
        plt.colorbar()

        if self.nay > 0:
            i0 = (self.nx - self.nax) // 2 
            j0 = (self.ny-1) // 2 - self.nay + 1
            x0 = i0 * self.diff
            y0 = j0 * self.diff
            rect = plt.Rectangle((x0, y0), self.nax*self.diff, self.nay*self.diff, linewidth=1, edgecolor='r', facecolor='none')
            plt.gca().add_patch(rect)

        if E:
            Ey, Ex = np.gradient(-phi, self.diff, self.diff)
            skip = (slice(None, None, step), slice(None, None, step))
            plt.quiver(X[skip], Y[skip], Ex[skip], Ey[skip], color='w')

        plt.xlabel('x')
        plt.ylabel('y')
        plt.gca().set_aspect("equal", adjustable="box")
        plt.title(s)
        plt.show()

    def Ey_plot(self, phi):
        phi = np.flipud(phi)
        Ey, _ = np.gradient(-phi, self.diff, self.diff)
        i0 = (self.ny-1) // 2

        print(Ey.shape)

        plt.plot(range(self.ny)[::-1], Ey[:, (self.nx-1)//2], label='Ey along center line')
        plt.plot((self.ny-1)//2 - self.nh, Ey[(self.ny-1)//2 + self.nh, (self.nx-1)//2], 'ro', label='charge position', alpha=0.5)
        plt.plot(i0, Ey[i0, (self.nx-1)//2], 'go', label='metal surface start', alpha=0.5)
        plt.xlabel('j')
        plt.ylabel('Ey')
        plt.legend()
        plt.tight_layout()
        plt.show()


    def induced_charge(self, phi, plot = True):
        phi = np.flipud(phi)
        Ey, _ = np.gradient(-phi, self.diff, self.diff)
        i0 = (self.nx - self.nax) // 2
        metal_surface = Ey[(self.ny-1)//2, i0 : i0 + self.nax]
        r = sum(metal_surface) * (self.diff) / self.q
        print("induced charge / q:", r)

        if plot:
            plt.plot(range(i0, i0+self.nax), metal_surface)
            plt.xlabel('i')
            plt.ylabel('Ey')
            plt.tight_layout()
            plt.show()

        return r


if __name__ == "__main__":
    simulator = simulator_2d(nx=701, ny=701, nax=201, nay=150, q=10.0, nh=5, diff=0.01)
    phi_vec, phi = simulator.poisson_solver(vector=True)
    print(-simulator.laplacian(phi_vec)[simulator.index((simulator.nx-1)//2, (simulator.ny-1)//2 - simulator.nh)])
    print(phi.shape)
    # simulator = simulator_2d(nx=9, ny=7, nax=3, nay=2, q=20.0, nh=3, diff=0.1)
    # simulator.test()
    simulator.plot(phi, E=True, step=15)
    simulator.Ey_plot(phi)
    simulator.induced_charge(phi, plot=True)
        </code></pre>
        </article>
    </main>
    <!-- JavaScript -->
    <script>
        function setLanguage(lang) {
            document.documentElement.lang = lang;
            document.getElementById('btn-ja').classList.toggle('lang-btn-active', lang === 'ja');
            document.getElementById('btn-en').classList.toggle('lang-btn-active', lang === 'en');
        }
    </script>
</body>
</html>